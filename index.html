<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello World</title>
</head>
<body>

    
    <script>

// lire quelques signaux non-intrusifs
const info = {
  lang: navigator.language,
  tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
  screen: `${screen.width}x${screen.height}@${devicePixelRatio||1} DPR`,
  mem: navigator.deviceMemory || 'unknown',
  cores: navigator.hardwareConcurrency || 'unknown',
  touch: navigator.maxTouchPoints || 0,
  theme: matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light',
  
  // Informations suppl√©mentaires
  platform: navigator.platform,
  vendor: navigator.vendor,
  cookiesEnabled: navigator.cookieEnabled,
  doNotTrack: navigator.doNotTrack === '1' || navigator.doNotTrack === 'yes',
  onLine: navigator.onLine,
  
  // D√©tection de plugins
  pdfViewerEnabled: navigator.pdfViewerEnabled || false,
  
  // Orientation et dimensions
  orientation: screen.orientation ? screen.orientation.type : 'unknown',
  windowSize: `${window.innerWidth}x${window.innerHeight}`,
  isFullscreen: window.innerWidth === screen.width && window.innerHeight === screen.height,
  
  // Contexte temporel
  now: new Date().toLocaleString('fr-FR'),
  dayOfWeek: new Intl.DateTimeFormat('fr-FR', { weekday: 'long' }).format(new Date()),
  
  // D√©tection du mode navigation priv√©e (tentative)
  possiblyIncognito: false,
  
  // D√©tection bloqueur de pub (simple test)
  adBlockDetected: false,
  
  // Informations r√©seau (m√©triques fiables uniquement)
  downlink: null,
  rtt: null,
  saveData: null,
  
  // Timezone d√©taill√©
  timezoneOffset: new Date().getTimezoneOffset(),
  
  // Pr√©f√©rences syst√®me
  languages: navigator.languages || [navigator.language],
  reducedMotion: matchMedia('(prefers-reduced-motion: reduce)').matches,
  highContrast: matchMedia('(prefers-contrast: high)').matches,
  
  // Fingerprints
  canvasFingerprint: null,
  webglFingerprint: null,
  audioFingerprint: null,
  
  // GPU Info
  gpuVendor: null,
  gpuRenderer: null,
  
  // Audio
  audioChannels: null,
  audioSampleRate: null,
  
  // Gamepads
  gamepadsConnected: 0,
  
  // Storage
  storageQuota: null,
  storageUsage: null,
  
  // Fonts d√©tect√©es
  fontsDetected: [],
  
  // G√©olocalisation (via IP)
  ipAddress: null,
  city: null,
  region: null,
  country: null,
  countryCode: null,
  postalCode: null,
  latitude: null,
  longitude: null,
  isp: null,
  org: null,
  
  // D√©tection VPN/Proxy
  vpnDetected: null,
  proxyDetected: null,
  torDetected: null,
  
  // D√©tection DevTools
  devToolsOpen: false,
  devToolsOpenCount: 0,
  devToolsFirstOpened: null,
  devToolsLastOpened: null,
  
  // Keyboard Layout
  keyboardLayout: 'unknown',
  
  // Media Devices
  videoInputs: 0,
  audioInputs: 0,
  audioOutputs: 0,
  
  // Tab Visibility
  tabSwitchCount: 0,
  currentlyAway: false,
  lastAwayTime: null,
  totalAwayTime: 0,
  longestAwayTime: 0,
  
  // Touch Tracking
  touchCount: 0,
  touchPoints: []
};

// G√©olocalisation via IP (sans consentement)
fetch('https://ipapi.co/json/')
  .then(response => response.json())
  .then(data => {
    info.ipAddress = data.ip;
    info.city = data.city;
    info.region = data.region;
    info.country = data.country_name;
    info.countryCode = data.country_code;
    info.postalCode = data.postal;
    info.latitude = data.latitude;
    info.longitude = data.longitude;
    info.isp = data.org;
    updateMessage();
  })
  .catch(err => {
    console.log('IP Geolocation failed:', err);
  });

// D√©tection VPN/Proxy/Tor via API
fetch('https://vpnapi.io/api/' + (info.ipAddress || ''))
  .then(response => response.json())
  .then(data => {
    if (data.security) {
      info.vpnDetected = data.security.vpn;
      info.proxyDetected = data.security.proxy;
      info.torDetected = data.security.tor;
      updateMessage();
    }
  })
  .catch(err => {
    // Essayer une API alternative
    fetch('https://proxycheck.io/v2/' + (info.ipAddress || '') + '?vpn=1&asn=1')
      .then(response => response.json())
      .then(data => {
        const ipData = data[info.ipAddress];
        if (ipData) {
          info.vpnDetected = ipData.proxy === 'yes' || ipData.type === 'VPN';
          info.proxyDetected = ipData.proxy === 'yes';
          updateMessage();
        }
      })
      .catch(err => console.log('VPN detection failed:', err));
  });

// Informations r√©seau (m√©triques pr√©cises uniquement)
if (navigator.connection) {
  info.downlink = navigator.connection.downlink ? `${navigator.connection.downlink} Mbps` : null;
  info.rtt = navigator.connection.rtt ? `${navigator.connection.rtt} ms` : null;
  info.saveData = navigator.connection.saveData || false;
}

// Test navigation priv√©e (pas fiable √† 100%)
try {
  if (!window.indexedDB || !window.localStorage) {
    info.possiblyIncognito = true;
  }
} catch(e) {
  info.possiblyIncognito = true;
}

// Canvas Fingerprint
function getCanvasFingerprint() {
  try {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 200;
    canvas.height = 50;
    
    ctx.textBaseline = 'top';
    ctx.font = '14px Arial';
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = '#f60';
    ctx.fillRect(125, 1, 62, 20);
    ctx.fillStyle = '#069';
    ctx.fillText('Canvas Fingerprint üé®', 2, 15);
    ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
    ctx.fillText('Canvas Fingerprint üé®', 4, 17);
    
    const dataURL = canvas.toDataURL();
    let hash = 0;
    for (let i = 0; i < dataURL.length; i++) {
      const char = dataURL.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(16).substring(0, 8);
  } catch(e) {
    return 'error';
  }
}

// WebGL Fingerprint
function getWebGLFingerprint() {
  try {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) return { vendor: 'not supported', renderer: 'not supported', fingerprint: 'none' };
    
    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
    const vendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'unknown';
    const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unknown';
    
    info.gpuVendor = vendor;
    info.gpuRenderer = renderer;
    
    // Cr√©er un fingerprint WebGL
    const params = [
      gl.getParameter(gl.VERSION),
      gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
      gl.getParameter(gl.VENDOR),
      gl.getParameter(gl.RENDERER),
      gl.getParameter(gl.MAX_TEXTURE_SIZE),
      gl.getParameter(gl.MAX_VERTEX_ATTRIBS)
    ].join('~');
    
    let hash = 0;
    for (let i = 0; i < params.length; i++) {
      const char = params.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    
    return hash.toString(16).substring(0, 8);
  } catch(e) {
    return 'error';
  }
}

// Audio Fingerprint
function getAudioFingerprint() {
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) return 'not supported';
    
    const context = new AudioContext();
    const oscillator = context.createOscillator();
    const analyser = context.createAnalyser();
    const gainNode = context.createGain();
    const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
    
    info.audioChannels = context.destination.maxChannelCount;
    info.audioSampleRate = context.sampleRate;
    
    gainNode.gain.value = 0;
    oscillator.type = 'triangle';
    oscillator.connect(analyser);
    analyser.connect(scriptProcessor);
    scriptProcessor.connect(gainNode);
    gainNode.connect(context.destination);
    oscillator.start(0);
    
    let hash = 0;
    scriptProcessor.onaudioprocess = function(event) {
      const output = event.outputBuffer.getChannelData(0);
      for (let i = 0; i < output.length; i++) {
        hash += Math.abs(output[i]);
      }
      oscillator.stop();
      scriptProcessor.disconnect();
      context.close();
    };
    
    setTimeout(() => {
      info.audioFingerprint = hash.toString(16).substring(0, 8);
      updateMessage();
    }, 100);
    
    return 'calculating...';
  } catch(e) {
    return 'error';
  }
}

// D√©tection de fonts
function detectFonts() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = '72px monospace';
  const baseWidth = ctx.measureText('mmmmmmmmmmlli').width;
  
  // Fonts syst√®me de base
  const systemFonts = [
    'Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Georgia', 
    'Palatino', 'Garamond', 'Comic Sans MS', 'Trebuchet MS', 'Impact',
    'Arial Black', 'Tahoma', 'Lucida Console', 'Courier', 'Lucida Sans Unicode',
    'MS Sans Serif', 'MS Serif', 'Helvetica', 'Calibri', 'Cambria'
  ];
  
  // Fonts t√©l√©charg√©es / non-standard (r√©v√®le des infos sur l'utilisateur)
  const downloadedFonts = [
    // Google Fonts populaires
    'Roboto', 'Open Sans', 'Lato', 'Montserrat', 'Poppins', 'Raleway',
    'Source Sans Pro', 'Oswald', 'Merriweather', 'PT Sans', 'Ubuntu',
    'Playfair Display', 'Nunito', 'Inter', 'Work Sans',
    
    // Adobe Fonts
    'Adobe Garamond Pro', 'Myriad Pro', 'Minion Pro', 'Proxima Nova',
    'Futura', 'Avenir', 'Brandon Grotesque', 'Gotham',
    
    // Fonts de design/d√©veloppement
    'Fira Code', 'JetBrains Mono', 'Source Code Pro', 'Consolas',
    'Monaco', 'Menlo', 'Inconsolata', 'SF Mono', 'Cascadia Code',
    
    // Fonts Adobe Creative Suite
    'Adobe Caslon Pro', 'Adobe Jenson Pro', 'Bickham Script Pro',
    'Trajan Pro', 'Warnock Pro',
    
    // Fonts Microsoft Office avanc√©es
    'Segoe UI', 'Segoe Print', 'Candara', 'Constantia', 'Corbel',
    
    // Fonts Apple
    'SF Pro Display', 'SF Pro Text', 'New York', 'Helvetica Neue',
    'Apple Chancery', 'Marker Felt', 'Noteworthy',
    
    // Fonts gaming/streaming
    'Bahnschrift', 'Ebrima', 'Nirmala UI',
    
    // Fonts professionnelles
    'DIN', 'Univers', 'Frutiger', 'Trade Gothic', 'Akzidenz Grotesk',
    'Franklin Gothic', 'News Gothic', 'Century Gothic'
  ];
  
  const detectedSystem = [];
  const detectedDownloaded = [];
  
  systemFonts.forEach(font => {
    ctx.font = `72px '${font}', monospace`;
    const width = ctx.measureText('mmmmmmmmmmlli').width;
    if (width !== baseWidth) {
      detectedSystem.push(font);
    }
  });
  
  downloadedFonts.forEach(font => {
    ctx.font = `72px '${font}', monospace`;
    const width = ctx.measureText('mmmmmmmmmmlli').width;
    if (width !== baseWidth) {
      detectedDownloaded.push(font);
    }
  });
  
  return {
    system: detectedSystem,
    downloaded: detectedDownloaded,
    total: detectedSystem.length + detectedDownloaded.length
  };
}

// D√©tection gamepads
function detectGamepads() {
  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
  let count = 0;
  for (let i = 0; i < gamepads.length; i++) {
    if (gamepads[i]) count++;
  }
  return count;
}

// Storage quota
if (navigator.storage && navigator.storage.estimate) {
  navigator.storage.estimate().then(estimate => {
    info.storageQuota = `${(estimate.quota / 1024 / 1024 / 1024).toFixed(2)} GB`;
    info.storageUsage = `${(estimate.usage / 1024 / 1024).toFixed(2)} MB`;
    updateMessage();
  });
}

// D√©tection Keyboard Layout
(function detectKeyboardLayout() {
  const layouts = {
    'azerty': ['a', 'z', 'e', 'r', 't', 'y'],
    'qwerty': ['q', 'w', 'e', 'r', 't', 'y'],
    'qwertz': ['q', 'w', 'e', 'r', 't', 'z'],
    'dvorak': ['\'', ',', '.', 'p', 'y', 'f']
  };
  
  // D√©tecter via la langue du navigateur (approximation)
  const lang = navigator.language.toLowerCase();
  if (lang.startsWith('fr') || lang.startsWith('be')) {
    info.keyboardLayout = 'AZERTY';
  } else if (lang.startsWith('de') || lang.startsWith('ch')) {
    info.keyboardLayout = 'QWERTZ';
  } else {
    info.keyboardLayout = 'QWERTY';
  }
  
  // D√©tecter via √©v√©nement clavier (plus pr√©cis)
  let keyPresses = [];
  const keyHandler = (e) => {
    keyPresses.push(e.key);
    if (keyPresses.length >= 3) {
      // Analyser les touches
      const keys = keyPresses.join('').toLowerCase();
      if (keys.includes('a') && keys.includes('z')) {
        info.keyboardLayout = 'AZERTY';
      } else if (keys.includes('q') && keys.includes('w')) {
        info.keyboardLayout = 'QWERTY';
      }
      document.removeEventListener('keydown', keyHandler);
      updateMessage();
    }
  };
  document.addEventListener('keydown', keyHandler);
})();

// D√©tection Media Devices (cam√©ras/micros)
(async function detectMediaDevices() {
  try {
    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
      const devices = await navigator.mediaDevices.enumerateDevices();
      
      info.videoInputs = devices.filter(d => d.kind === 'videoinput').length;
      info.audioInputs = devices.filter(d => d.kind === 'audioinput').length;
      info.audioOutputs = devices.filter(d => d.kind === 'audiooutput').length;
      
      updateMessage();
    }
  } catch (err) {
    console.log('Media devices detection failed:', err);
  }
})();

// D√©tection Tab Visibility (changement d'onglet)
(function detectTabVisibility() {
  let awayStartTime = null;
  let awayDuration = 0;
  
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // L'utilisateur vient de quitter l'onglet
      info.currentlyAway = true;
      info.tabSwitchCount++;
      awayStartTime = Date.now();
      info.lastAwayTime = new Date().toLocaleTimeString('fr-FR');
    } else {
      // L'utilisateur revient sur l'onglet
      if (awayStartTime) {
        awayDuration = Math.floor((Date.now() - awayStartTime) / 1000);
        info.totalAwayTime += awayDuration;
        if (awayDuration > info.longestAwayTime) {
          info.longestAwayTime = awayDuration;
        }
        info.currentlyAway = false;
        
        // FAIRE VIBRER LE T√âL√âPHONE (Android)
        if (navigator.vibrate) {
          navigator.vibrate([200, 100, 200, 100, 300]); // Pattern creepy
        }
        
        // Afficher l'overlay de retour
        showTabReturnWarning(awayDuration);
        
        // Masquer l'overlay apr√®s 5 secondes
        setTimeout(() => {
          hideTabAwayWarning();
        }, 5000);
        
        updateMessage();
      }
    }
  });
})();

// Touch Tracking & Heatmap
(function setupTouchTracking() {
  let canvas = null;
  let ctx = null;
  let isVisible = false;
  
  // Cr√©er le canvas pour le heatmap IMM√âDIATEMENT
  function createCanvas() {
    canvas = document.createElement('canvas');
    canvas.id = 'touch-heatmap';
    canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 999997;
      display: none;
      background: rgba(255, 255, 255, 0.1);
    `;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.body.appendChild(canvas);
    ctx = canvas.getContext('2d');
    console.log('Canvas cr√©√©:', canvas.width, 'x', canvas.height);
  }
  
  // Cr√©er le canvas d√®s le chargement
  if (document.body) {
    createCanvas();
  } else {
    document.addEventListener('DOMContentLoaded', createCanvas);
  }
  
  // Dessiner une empreinte digitale
  function drawFingerprint(x, y) {
    if (!ctx) {
      console.log('Pas de ctx!');
      return;
    }
    
    console.log('Dessiner empreinte √†', x, y);
    
    // Rotation al√©atoire pour plus de r√©alisme
    const rotation = Math.random() * Math.PI * 2;
    
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    
    // Empreinte ovale avec d√©grad√©
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 35);
    gradient.addColorStop(0, 'rgba(80, 80, 80, 0.4)');
    gradient.addColorStop(0.6, 'rgba(60, 60, 60, 0.25)');
    gradient.addColorStop(1, 'rgba(40, 40, 40, 0)');
    
    // Fond ovale
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.ellipse(0, 0, 35, 45, 0, 0, Math.PI * 2); // Ovale vertical
    ctx.fill();
    
    // Lignes d'empreinte digitale (courbes)
    ctx.strokeStyle = 'rgba(40, 40, 40, 0.35)';
    ctx.lineWidth = 1.5;
    
    // Lignes courbes pour simuler les cr√™tes de l'empreinte
    for (let i = 0; i < 7; i++) {
      ctx.beginPath();
      const offset = -25 + i * 8;
      
      // Courbe sinuso√Ødale pour effet r√©aliste
      for (let t = -40; t <= 40; t += 2) {
        const xPos = offset + Math.sin(t / 15) * 3;
        const yPos = t;
        
        if (t === -40) {
          ctx.moveTo(xPos, yPos);
        } else {
          ctx.lineTo(xPos, yPos);
        }
      }
      ctx.stroke();
    }
    
    // Quelques points pour plus de d√©tails
    ctx.fillStyle = 'rgba(30, 30, 30, 0.2)';
    for (let i = 0; i < 8; i++) {
      const px = (Math.random() - 0.5) * 50;
      const py = (Math.random() - 0.5) * 70;
      ctx.beginPath();
      ctx.arc(px, py, 1, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  }
  
  // Tracker les touches
  function trackTouch(e) {
    const touches = e.touches || e.changedTouches || [e];
    
    for (let i = 0; i < touches.length; i++) {
      const touch = touches[i];
      const x = touch.clientX || touch.pageX;
      const y = touch.clientY || touch.pageY;
      
      info.touchPoints.push({ x, y, time: Date.now() });
      info.touchCount++;
      
      console.log('Touch enregistr√©:', x, y, 'Total:', info.touchCount);
    }
    
    updateMessage();
  }
  
  // √âcouter les √©v√©nements
  document.addEventListener('touchstart', trackTouch, { passive: true });
  document.addEventListener('touchmove', trackTouch, { passive: true });
  
  // Aussi tracker les clics (desktop)
  document.addEventListener('mousedown', (e) => {
    info.touchPoints.push({ x: e.clientX, y: e.clientY, time: Date.now() });
    info.touchCount++;
    console.log('Click enregistr√©:', e.clientX, e.clientY, 'Total:', info.touchCount);
    updateMessage();
  });
  
  // Fonction pour afficher/masquer le heatmap
  window.toggleTouchHeatmap = function() {
    if (!canvas) {
      console.log('Canvas pas encore cr√©√©!');
      createCanvas();
    }
    
    isVisible = !isVisible;
    console.log('¬≤ heatmap:', isVisible, 'Points:', info.touchPoints.length);
    
    if (isVisible) {
      canvas.style.display = 'block';
      // Redessiner toutes les empreintes
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      console.log('Dessin de', info.touchPoints.length, 'empreintes');
      info.touchPoints.forEach((point, index) => {
        console.log('Empreinte', index, ':', point.x, point.y);
        drawFingerprint(point.x, point.y);
      });
    } else {
      canvas.style.display = 'none';
    }
  };
  
  // Redimensionner le canvas si la fen√™tre change
  window.addEventListener('resize', () => {
    if (canvas) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (isVisible) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        info.touchPoints.forEach(point => {
          drawFingerprint(point.x, point.y);
        });
      }
    }
  });
  
  // Affichage automatique : 4 traces OU 30 secondes (si au moins 1 trace)
  let hasShownHeatmap = false;
  let startTime = Date.now();
  
  // V√©rifier toutes les 500ms
  const checkInterval = setInterval(() => {
    if (hasShownHeatmap) {
      clearInterval(checkInterval);
      return;
    }
    
    const elapsed = (Date.now() - startTime) / 1000;
    const traceCount = info.touchPoints.length;
    
    // Condition 1: 4 traces
    if (traceCount >= 4) {
      console.log('üî• 4 TRACES D√âTECT√âES ! Affichage du heatmap...');
      hasShownHeatmap = true;
      clearInterval(checkInterval);
      showCreepyHeatmap();
    }
    // Condition 2: 30 secondes ET au moins 1 trace
    else if (elapsed >= 30 && traceCount >= 1) {
      console.log('‚è∞ 30 SECONDES √âCOUL√âES ! Affichage du heatmap...');
      hasShownHeatmap = true;
      clearInterval(checkInterval);
      showCreepyHeatmap();
    }
  }, 500);
  
  // Fonction pour afficher le heatmap en mode creepy
  function showCreepyHeatmap() {
    console.log('üëÅÔ∏è MODE CREEPY ACTIV√â');
    console.log('üìä Empreintes √† afficher:', info.touchPoints.length);
    
    // Cr√©er un overlay noir
    const overlay = document.createElement('div');
    overlay.id = 'creepy-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      z-index: 999999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      font-family: system-ui;
    `;
    
    overlay.innerHTML = `
      <div style="text-align: center; margin-bottom: 30px;">
        <div style="font-size: 60px; margin-bottom: 20px; animation: pulse 2s infinite;">üëÅÔ∏è</div>
        <div style="font-size: 36px; font-weight: bold; margin-bottom: 15px;">
          JE VOIS TOUT
        </div>
        <div style="font-size: 24px; opacity: 0.8;">
          ${info.touchPoints.length} empreintes digitales enregistr√©es...
        </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Afficher le canvas avec les empreintes PAR-DESSUS l'overlay noir
    if (canvas) {
      canvas.style.zIndex = '1000000';
      canvas.style.display = 'block';
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Dessiner toutes les empreintes
      info.touchPoints.forEach(point => {
        drawFingerprint(point.x, point.y);
      });
    }
    
    // Faire dispara√Ætre apr√®s 5 secondes
    setTimeout(() => {
      overlay.style.transition = 'opacity 1s';
      overlay.style.opacity = '0';
      canvas.style.transition = 'opacity 1s';
      canvas.style.opacity = '0';
      
      setTimeout(() => {
        overlay.remove();
        canvas.style.display = 'none';
        canvas.style.opacity = '1';
        canvas.style.zIndex = '999997';
      }, 1000);
    }, 5000);
  }
  
  // Exposer la fonction globalement
  window.showCreepyHeatmap = showCreepyHeatmap;
})();

// Fonctions pour l'overlay Tab Away
function showTabReturnWarning(awaySeconds) {
  let overlay = document.getElementById('tab-away-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'tab-away-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      color: white;
      z-index: 999998;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, sans-serif;
      text-align: center;
    `;
    document.body.appendChild(overlay);
  }
  
  const minutes = Math.floor(awaySeconds / 60);
  const secs = awaySeconds % 60;
  const timeStr = minutes > 0 ? `${minutes}m ${secs}s` : `${secs}s`;
  
  overlay.innerHTML = `
    <div style="animation: pulse 2s infinite;">
      <div style="font-size: 80px; margin-bottom: 20px;">üëÄ</div>
      <div style="font-size: 48px; font-weight: bold; margin-bottom: 20px;">
        TU √âTAIS O√ô ?
      </div>
      <div style="font-size: 32px; margin-bottom: 30px; color: #ff6b6b;">
        Tu es parti pendant ${timeStr}
      </div>
      <div style="font-size: 24px; opacity: 0.8;">
        Tu regardais quoi ? ü§î
      </div>
      <div style="font-size: 18px; margin-top: 30px; opacity: 0.6;">
        C'est la ${info.tabSwitchCount}√®me fois que tu pars...
      </div>
      <div style="font-size: 14px; margin-top: 20px; opacity: 0.5;">
        (Ce message dispara√Ætra dans 5 secondes)
      </div>
    </div>
  `;
  
  overlay.style.display = 'flex';
}

function hideTabAwayWarning() {
  const overlay = document.getElementById('tab-away-overlay');
  if (overlay) {
    overlay.style.display = 'none';
  }
}

// Ex√©cuter les fingerprints
info.canvasFingerprint = getCanvasFingerprint();
info.webglFingerprint = getWebGLFingerprint();
info.audioFingerprint = getAudioFingerprint();
info.fontsDetected = detectFonts();
info.gamepadsConnected = detectGamepads();

// Test bloqueur de pub basique
const adTest = document.createElement('div');
adTest.innerHTML = '&nbsp;';
adTest.className = 'adsbox';
adTest.style.position = 'absolute';
adTest.style.left = '-9999px';
document.body.appendChild(adTest);
setTimeout(() => {
  if (adTest.offsetHeight === 0) {
    info.adBlockDetected = true;
  }
  adTest.remove();
  updateMessage();
}, 100);

// D√©tection niveau de batterie (si disponible, sans demander permission)
if (navigator.getBattery) {
  navigator.getBattery().then(battery => {
    info.battery = `${Math.round(battery.level * 100)}%`;
    info.charging = battery.charging;
    updateMessage();
  });
}

// D√©tection DevTools (multiple m√©thodes)
(function detectDevTools() {
  // D√©sactiver sur mobile pour √©viter les faux positifs
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   navigator.maxTouchPoints > 0 || 
                   'ontouchstart' in window;
  
  if (isMobile) {
    console.log('Mobile d√©tect√© - d√©tection DevTools d√©sactiv√©e');
    return; // Ne pas d√©tecter sur mobile
  }
  
  const threshold = 160;
  let devToolsWasOpen = false;
  
  // M√©thode 1: D√©tection via la taille de la fen√™tre
  function checkWindowSize() {
    const widthThreshold = window.outerWidth - window.innerWidth > threshold;
    const heightThreshold = window.outerHeight - window.innerHeight > threshold;
    return widthThreshold || heightThreshold;
  }
  
  // M√©thode 2: D√©tection via console.log timing
  let devtools = { open: false, orientation: null };
  const element = new Image();
  Object.defineProperty(element, 'id', {
    get: function() {
      devtools.open = true;
      devtools.orientation = (window.outerHeight - window.innerHeight > threshold) ? 'vertical' : 'horizontal';
      return 'devtools-detector';
    }
  });
  
  // M√©thode 3: D√©tection via debugger statement timing
  function checkDebugger() {
    const start = performance.now();
    debugger;
    const end = performance.now();
    return end - start > 100; // Si debugger prend du temps, DevTools est ouvert
  }
  
  // V√©rification continue
  setInterval(() => {
    // Reset pour re-d√©tecter
    devtools.open = false;
    
    // Trigger la d√©tection via console
    console.log('%c', element);
    console.clear();
    
    // V√©rifier via taille de fen√™tre
    const sizeCheck = checkWindowSize();
    
    const isOpen = devtools.open || sizeCheck;
    
    if (isOpen && !info.devToolsOpen) {
      // DevTools vient d'√™tre ouvert
      info.devToolsOpen = true;
      info.devToolsOpenCount++;
      info.devToolsLastOpened = new Date().toLocaleTimeString('fr-FR');
      if (!info.devToolsFirstOpened) {
        info.devToolsFirstOpened = new Date().toLocaleTimeString('fr-FR');
      }
      updateMessage();
      showDevToolsWarning();
      
      // Message dans la console pour troller
      console.log('%cüëÄ Je te vois !', 'font-size: 30px; color: red; font-weight: bold;');
      console.log('%cTu inspectes mon code ? Int√©ressant... üïµÔ∏è', 'font-size: 16px; color: orange;');
      console.log('%cNombre de fois que tu as ouvert les DevTools: ' + info.devToolsOpenCount, 'font-size: 14px; color: blue;');
    } else if (!isOpen && info.devToolsOpen) {
      // DevTools vient d'√™tre ferm√©
      info.devToolsOpen = false;
      updateMessage();
      hideDevToolsWarning();
    }
    
    // Mettre √† jour l'overlay si DevTools est ouvert
    if (info.devToolsOpen) {
      updateDevToolsWarning();
    }
  }, 500);
})();

// Fonctions pour l'overlay DevTools
function showDevToolsWarning() {
  let overlay = document.getElementById('devtools-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'devtools-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #ff0000, #ff6b00);
      color: white;
      padding: 20px;
      z-index: 999999;
      text-align: center;
      font-family: system-ui, -apple-system, sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      animation: slideDown 0.3s ease-out;
    `;
    document.body.appendChild(overlay);
    
    // Ajouter l'animation CSS
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideDown {
        from { transform: translateY(-100%); }
        to { transform: translateY(0); }
      }
      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }
    `;
    document.head.appendChild(style);
  }
  overlay.style.display = 'block';
  updateDevToolsWarning();
}

function hideDevToolsWarning() {
  const overlay = document.getElementById('devtools-overlay');
  if (overlay) {
    overlay.style.display = 'none';
  }
}

function updateDevToolsWarning() {
  const overlay = document.getElementById('devtools-overlay');
  if (overlay && info.devToolsOpen) {
    overlay.innerHTML = `
      <div style="animation: pulse 2s infinite;">
        <div style="font-size: 48px; margin-bottom: 10px;">üëÄ</div>
        <div style="font-size: 32px; font-weight: bold; margin-bottom: 10px;">JE TE VOIS !</div>
        <div style="font-size: 20px; margin-bottom: 15px;">Tu es en train d'inspecter mon code...</div>
        <div style="font-size: 16px; opacity: 0.9;">
          üìä Ouvert ${info.devToolsOpenCount} fois | üïê Derni√®re fois: ${info.devToolsLastOpened}
        </div>
        <div style="font-size: 14px; margin-top: 10px; opacity: 0.8;">
          Ferme les DevTools pour faire dispara√Ætre ce message üòè
        </div>
      </div>
    `;
  }
}

function updateMessage() {
  const messages = [];
  
  messages.push(`üëã Salut ! Je vois que tu es sur un √©cran ${info.screen}`);
  
  // Informations IP
  if (info.ipAddress) {
    messages.push(`üåê IP: ${info.ipAddress}`);
  }
  if (info.isp) {
    messages.push(`üè¢ Fournisseur: ${info.isp}`);
  }
  
  messages.push(`üåç Tu es en ${info.lang} (${info.tz}, offset: ${info.timezoneOffset} min)`);
  messages.push(`üó£Ô∏è Langues: ${info.languages.join(', ')}`);
  messages.push(`üìÖ On est ${info.dayOfWeek}, il est ${info.now.split(' ')[1]}`);
  messages.push(`üíª Plateforme: ${info.platform} (${info.vendor})`);
  messages.push(`üñ•Ô∏è Fen√™tre: ${info.windowSize} ${info.isFullscreen ? '(plein √©cran)' : '(pas en plein √©cran)'}`);
  messages.push(`üì± Orientation: ${info.orientation}`);
  messages.push(`üé® Th√®me pr√©f√©r√©: ${info.theme}`);
  
  // R√©seau (m√©triques fiables uniquement)
  if (info.downlink) {
    messages.push(`‚ö° Vitesse connexion: ${info.downlink}`);
  }
  if (info.rtt) {
    messages.push(`üì° Latence r√©seau: ${info.rtt}`);
  }
  if (info.saveData) {
    messages.push(`üíæ Mode √©conomie donn√©es activ√©`);
  }
  
  messages.push(`üß† M√©moire: ${info.mem} GB, ${info.cores} c≈ìurs`);
  messages.push(`üëÜ Points de contact: ${info.touch} ${info.touch > 0 ? '(appareil tactile)' : '(pas tactile)'}`);
  messages.push(`üåê ${info.onLine ? 'En ligne' : 'Hors ligne'}`);
  messages.push(`üç™ Cookies: ${info.cookiesEnabled ? 'activ√©s' : 'd√©sactiv√©s'}`);
  
  // Pr√©f√©rences syst√®me
  if (info.reducedMotion) {
    messages.push(`‚ôø Animations r√©duites activ√©es`);
  }
  if (info.highContrast) {
    messages.push(`üîÜ Contraste √©lev√© activ√©`);
  }
  
  // Batterie
  if (info.battery) {
    messages.push(`üîã Batterie: ${info.battery} ${info.charging ? '(en charge ‚ö°)' : '(sur batterie)'}`);
  }
  
  // GPU
  if (info.gpuVendor && info.gpuVendor !== 'unknown') {
    messages.push(`üéÆ GPU: ${info.gpuVendor}`);
    messages.push(`üñºÔ∏è Renderer: ${info.gpuRenderer}`);
  }
  
  // Audio
  if (info.audioChannels) {
    messages.push(`üîä Audio: ${info.audioChannels} canaux, ${info.audioSampleRate} Hz`);
  }
  
  // Gamepads
  if (info.gamepadsConnected > 0) {
    messages.push(`üéÆ ${info.gamepadsConnected} manette(s) connect√©e(s) !`);
  }
  
  // Keyboard Layout
  if (info.keyboardLayout !== 'unknown') {
    messages.push(`<br><strong>‚å®Ô∏è Disposition clavier :</strong>`);
    messages.push(`   ${info.keyboardLayout}`);
  }
  
  // Media Devices
  if (info.videoInputs > 0 || info.audioInputs > 0 || info.audioOutputs > 0) {
    messages.push(`<br><strong>üé• P√©riph√©riques m√©dia d√©tect√©s :</strong>`);
    if (info.videoInputs > 0) {
      messages.push(`   üìπ ${info.videoInputs} cam√©ra(s) d√©tect√©e(s)`);
    }
    if (info.audioInputs > 0) {
      messages.push(`   üé§ ${info.audioInputs} microphone(s) d√©tect√©(s)`);
    }
    if (info.audioOutputs > 0) {
      messages.push(`   üîä ${info.audioOutputs} sortie(s) audio d√©tect√©e(s)`);
    }
  }
  
  // Storage
  if (info.storageQuota) {
    messages.push(`üíø Stockage: ${info.storageUsage} utilis√©s sur ${info.storageQuota} disponibles`);
  }
  
  // Fingerprints
  messages.push(`üîê Canvas Fingerprint: ${info.canvasFingerprint}`);
  messages.push(`üîê WebGL Fingerprint: ${info.webglFingerprint}`);
  if (info.audioFingerprint && info.audioFingerprint !== 'calculating...') {
    messages.push(`üîê Audio Fingerprint: ${info.audioFingerprint}`);
  }
  
  // Fonts
  if (info.fontsDetected && info.fontsDetected.total > 0) {
    messages.push(`üî§ ${info.fontsDetected.system.length} fonts syst√®me d√©tect√©es`);
    
    if (info.fontsDetected.downloaded.length > 0) {
      messages.push(`üì• ${info.fontsDetected.downloaded.length} fonts t√©l√©charg√©es/sp√©ciales d√©tect√©es:`);
      messages.push(`   ‚Üí ${info.fontsDetected.downloaded.join(', ')}`);
    }
  }
  
  // D√©tection DevTools
  if (info.devToolsOpen) {
    messages.push(`<br><strong style="color: red; font-size: 20px;">üëÄ JE TE VOIS !</strong>`);
    messages.push(`<strong style="color: orange; font-size: 18px;">üî¥ Tu es en train d'inspecter mon code en ce moment m√™me...</strong>`);
    messages.push(`   üìä Tu as ouvert les DevTools ${info.devToolsOpenCount} fois`);
    if (info.devToolsFirstOpened) {
      messages.push(`   ‚è∞ Premi√®re fois: ${info.devToolsFirstOpened}`);
    }
    messages.push(`   üïê Derni√®re fois: ${info.devToolsLastOpened}`);
    messages.push(`<em style="color: #666;">Ferme les DevTools et regarde ce qui se passe... üòè</em>`);
  } else if (info.devToolsOpenCount > 0) {
    messages.push(`<br><strong>üëÄ D√©tection DevTools :</strong>`);
    messages.push(`   ‚ö™ DevTools ferm√© (pour l'instant...)`);
    messages.push(`   üìä Tu les as ouverts ${info.devToolsOpenCount} fois`);
    if (info.devToolsFirstOpened) {
      messages.push(`   ‚è∞ Premi√®re ouverture: ${info.devToolsFirstOpened}`);
    }
    messages.push(`   üïê Derni√®re ouverture: ${info.devToolsLastOpened}`);
  }
  
  // Tab Visibility Stats
  if (info.tabSwitchCount > 0) {
    messages.push(`<br><strong>üëÄ Changements d'onglet d√©tect√©s :</strong>`);
    messages.push(`   üìä Tu es parti ${info.tabSwitchCount} fois`);
    if (info.totalAwayTime > 0) {
      const totalMins = Math.floor(info.totalAwayTime / 60);
      const totalSecs = info.totalAwayTime % 60;
      messages.push(`   ‚è±Ô∏è Temps total absent : ${totalMins}m ${totalSecs}s`);
    }
    if (info.longestAwayTime > 0) {
      const longMins = Math.floor(info.longestAwayTime / 60);
      const longSecs = info.longestAwayTime % 60;
      messages.push(`   üèÜ Plus longue absence : ${longMins}m ${longSecs}s`);
    }
    if (info.lastAwayTime) {
      messages.push(`   üïê Dernier d√©part : ${info.lastAwayTime}`);
    }
  }
  
  // Touch Tracking Stats
  if (info.touchCount > 0) {
    messages.push(`   üëÜ ${info.touchCount} empreintes digitales d√©tect√©es`);
  }
  
  // D√©tection VPN/Proxy/Tor
  if (info.vpnDetected !== null || info.proxyDetected !== null || info.torDetected !== null) {
    messages.push(`<br><strong>üîí Analyse de s√©curit√© :</strong>`);
    if (info.vpnDetected === true) {
      messages.push(`   üõ°Ô∏è VPN d√©tect√© ! Tu caches ta vraie localisation`);
    } else if (info.vpnDetected === false) {
      messages.push(`   ‚úì Pas de VPN d√©tect√©`);
    }
    if (info.proxyDetected === true) {
      messages.push(`   üîÄ Proxy d√©tect√© !`);
    }
    if (info.torDetected === true) {
      messages.push(`   üßÖ Tor d√©tect√© ! Tu es vraiment parano üòè`);
    }
  }
  
  // D√©tections sp√©ciales
  if (info.doNotTrack) {
    messages.push(`üïµÔ∏è Do Not Track activ√© (mais je te vois quand m√™me üòè)`);
  }
  
  if (info.adBlockDetected) {
    messages.push(`üõ°Ô∏è Bloqueur de pub d√©tect√© !`);
  }
  
  if (info.possiblyIncognito) {
    messages.push(`ü•∑ Tu es peut-√™tre en navigation priv√©e...`);
  }
  
  if (info.pdfViewerEnabled) {
    messages.push(`üìÑ Lecteur PDF int√©gr√© d√©tect√©`);
  }
  

  
  const container = document.getElementById('info-display') || createInfoDisplay();
  container.innerHTML = messages.map(m => `<p style="margin: 5px 0;">${m}</p>`).join('');
}

function createInfoDisplay() {
  const div = document.createElement('div');
  div.id = 'info-display';
  div.style.cssText = 'padding: 20px; background: #f0f0f0; border-radius: 10px; margin: 20px 0; font-family: system-ui;';
  document.body.prepend(div);
  return div;
}

document.addEventListener('DOMContentLoaded', updateMessage);

// Mise √† jour du temps pass√© sur la page
let secondsOnPage = 0;
setInterval(() => {
  secondsOnPage++;
  const timeDisplay = document.getElementById('time-on-page') || createTimeDisplay();
  const minutes = Math.floor(secondsOnPage / 60);
  const seconds = secondsOnPage % 60;
  timeDisplay.textContent = `‚è±Ô∏è Temps sur la page: ${minutes}m ${seconds}s`;
}, 1000);

function createTimeDisplay() {
  const div = document.createElement('div');
  div.id = 'time-on-page';
  div.style.cssText = 'position: fixed; bottom: 20px; right: 20px; padding: 10px 15px; background: #333; color: white; border-radius: 5px; font-family: monospace; font-size: 14px;';
  document.body.appendChild(div);
  return div;
}

    </script>
</body>
</html>