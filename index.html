<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello World</title>
</head>
<body>

    
    <script>

// lire quelques signaux non-intrusifs
const info = {
  lang: navigator.language,
  tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
  screen: `${screen.width}x${screen.height}@${devicePixelRatio||1} DPR`,
  mem: navigator.deviceMemory || 'unknown',
  cores: navigator.hardwareConcurrency || 'unknown',
  touch: navigator.maxTouchPoints || 0,
  theme: matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light',
  
  // Informations supplÃ©mentaires
  platform: navigator.platform,
  vendor: navigator.vendor,
  cookiesEnabled: navigator.cookieEnabled,
  doNotTrack: navigator.doNotTrack === '1' || navigator.doNotTrack === 'yes',
  onLine: navigator.onLine,
  
  // DÃ©tection de plugins
  pdfViewerEnabled: navigator.pdfViewerEnabled || false,
  
  // Orientation et dimensions
  orientation: screen.orientation ? screen.orientation.type : 'unknown',
  windowSize: `${window.innerWidth}x${window.innerHeight}`,
  isFullscreen: window.innerWidth === screen.width && window.innerHeight === screen.height,
  
  // Contexte temporel
  now: new Date().toLocaleString('fr-FR'),
  dayOfWeek: new Intl.DateTimeFormat('fr-FR', { weekday: 'long' }).format(new Date()),
  
  // DÃ©tection du mode navigation privÃ©e (tentative)
  possiblyIncognito: false,
  
  // DÃ©tection bloqueur de pub (simple test)
  adBlockDetected: false,
  
  // Informations rÃ©seau (mÃ©triques fiables uniquement)
  downlink: null,
  rtt: null,
  saveData: null,
  
  // Timezone dÃ©taillÃ©
  timezoneOffset: new Date().getTimezoneOffset(),
  
  // PrÃ©fÃ©rences systÃ¨me
  languages: navigator.languages || [navigator.language],
  reducedMotion: matchMedia('(prefers-reduced-motion: reduce)').matches,
  highContrast: matchMedia('(prefers-contrast: high)').matches,
  
  // Fingerprints
  canvasFingerprint: null,
  webglFingerprint: null,
  audioFingerprint: null,
  
  // GPU Info
  gpuVendor: null,
  gpuRenderer: null,
  
  // Audio
  audioChannels: null,
  audioSampleRate: null,
  
  // Gamepads
  gamepadsConnected: 0,
  
  // Storage
  storageQuota: null,
  storageUsage: null,
  
  // Fonts dÃ©tectÃ©es
  fontsDetected: [],
  
  // GÃ©olocalisation (via IP)
  ipAddress: null,
  city: null,
  region: null,
  country: null,
  countryCode: null,
  postalCode: null,
  latitude: null,
  longitude: null,
  isp: null,
  org: null,
  
  // DÃ©tection VPN/Proxy
  vpnDetected: null,
  proxyDetected: null,
  torDetected: null,
  
  // DÃ©tection DevTools
  devToolsOpen: false,
  devToolsOpenCount: 0,
  devToolsFirstOpened: null,
  devToolsLastOpened: null,
  
  // Keyboard Layout
  keyboardLayout: 'unknown',
  
  // Media Devices
  videoInputs: 0,
  audioInputs: 0,
  audioOutputs: 0,
  
  // Tab Visibility
  tabSwitchCount: 0,
  currentlyAway: false,
  lastAwayTime: null,
  totalAwayTime: 0,
  longestAwayTime: 0,
  
  // Touch Tracking
  touchCount: 0,
  touchPoints: [],
  
  // Long Press Tracking
  longPresses: [],
  currentLongPress: null
};

// Forcer la rÃ©initialisation au chargement (pour Ã©viter le bfcache)
window.addEventListener('pageshow', (event) => {
  if (event.persisted) {
    // Page restaurÃ©e depuis le cache, forcer la rÃ©initialisation
    console.log('ğŸ”„ Page restaurÃ©e depuis cache - RÃ©initialisation forcÃ©e');
    info.touchCount = 0;
    info.touchPoints = [];
    updateMessage();
  }
});

// GÃ©olocalisation via IP (sans consentement)
fetch('https://ipapi.co/json/')
  .then(response => response.json())
  .then(data => {
    info.ipAddress = data.ip;
    info.city = data.city;
    info.region = data.region;
    info.country = data.country_name;
    info.countryCode = data.country_code;
    info.postalCode = data.postal;
    info.latitude = data.latitude;
    info.longitude = data.longitude;
    info.isp = data.org;
    updateMessage();
  })
  .catch(err => {
    console.log('IP Geolocation failed:', err);
  });

// DÃ©tection VPN/Proxy/Tor via API
fetch('https://vpnapi.io/api/' + (info.ipAddress || ''))
  .then(response => response.json())
  .then(data => {
    if (data.security) {
      info.vpnDetected = data.security.vpn;
      info.proxyDetected = data.security.proxy;
      info.torDetected = data.security.tor;
      updateMessage();
    }
  })
  .catch(err => {
    // Essayer une API alternative
    fetch('https://proxycheck.io/v2/' + (info.ipAddress || '') + '?vpn=1&asn=1')
      .then(response => response.json())
      .then(data => {
        const ipData = data[info.ipAddress];
        if (ipData) {
          info.vpnDetected = ipData.proxy === 'yes' || ipData.type === 'VPN';
          info.proxyDetected = ipData.proxy === 'yes';
          updateMessage();
        }
      })
      .catch(err => console.log('VPN detection failed:', err));
  });

// Informations rÃ©seau (mÃ©triques prÃ©cises uniquement)
if (navigator.connection) {
  info.downlink = navigator.connection.downlink ? `${navigator.connection.downlink} Mbps` : null;
  info.rtt = navigator.connection.rtt ? `${navigator.connection.rtt} ms` : null;
  info.saveData = navigator.connection.saveData || false;
}

// Test navigation privÃ©e (pas fiable Ã  100%)
try {
  if (!window.indexedDB || !window.localStorage) {
    info.possiblyIncognito = true;
  }
} catch(e) {
  info.possiblyIncognito = true;
}

// Canvas Fingerprint
function getCanvasFingerprint() {
  try {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 200;
    canvas.height = 50;
    
    ctx.textBaseline = 'top';
    ctx.font = '14px Arial';
    ctx.textBaseline = 'alphabetic';
    ctx.fillStyle = '#f60';
    ctx.fillRect(125, 1, 62, 20);
    ctx.fillStyle = '#069';
    ctx.fillText('Canvas Fingerprint ğŸ¨', 2, 15);
    ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
    ctx.fillText('Canvas Fingerprint ğŸ¨', 4, 17);
    
    const dataURL = canvas.toDataURL();
    let hash = 0;
    for (let i = 0; i < dataURL.length; i++) {
      const char = dataURL.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString(16).substring(0, 8);
  } catch(e) {
    return 'error';
  }
}

// WebGL Fingerprint
function getWebGLFingerprint() {
  try {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) return { vendor: 'not supported', renderer: 'not supported', fingerprint: 'none' };
    
    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
    const vendor = debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'unknown';
    const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'unknown';
    
    info.gpuVendor = vendor;
    info.gpuRenderer = renderer;
    
    // CrÃ©er un fingerprint WebGL
    const params = [
      gl.getParameter(gl.VERSION),
      gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
      gl.getParameter(gl.VENDOR),
      gl.getParameter(gl.RENDERER),
      gl.getParameter(gl.MAX_TEXTURE_SIZE),
      gl.getParameter(gl.MAX_VERTEX_ATTRIBS)
    ].join('~');
    
    let hash = 0;
    for (let i = 0; i < params.length; i++) {
      const char = params.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    
    return hash.toString(16).substring(0, 8);
  } catch(e) {
    return 'error';
  }
}

// Audio Fingerprint
function getAudioFingerprint() {
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) return 'not supported';
    
    const context = new AudioContext();
    const oscillator = context.createOscillator();
    const analyser = context.createAnalyser();
    const gainNode = context.createGain();
    const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
    
    info.audioChannels = context.destination.maxChannelCount;
    info.audioSampleRate = context.sampleRate;
    
    gainNode.gain.value = 0;
    oscillator.type = 'triangle';
    oscillator.connect(analyser);
    analyser.connect(scriptProcessor);
    scriptProcessor.connect(gainNode);
    gainNode.connect(context.destination);
    oscillator.start(0);
    
    let hash = 0;
    scriptProcessor.onaudioprocess = function(event) {
      const output = event.outputBuffer.getChannelData(0);
      for (let i = 0; i < output.length; i++) {
        hash += Math.abs(output[i]);
      }
      oscillator.stop();
      scriptProcessor.disconnect();
      context.close();
    };
    
    setTimeout(() => {
      info.audioFingerprint = hash.toString(16).substring(0, 8);
      updateMessage();
    }, 100);
    
    return 'calculating...';
  } catch(e) {
    return 'error';
  }
}

// DÃ©tection de fonts
function detectFonts() {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = '72px monospace';
  const baseWidth = ctx.measureText('mmmmmmmmmmlli').width;
  
  // Fonts systÃ¨me de base
  const systemFonts = [
    'Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Georgia', 
    'Palatino', 'Garamond', 'Comic Sans MS', 'Trebuchet MS', 'Impact',
    'Arial Black', 'Tahoma', 'Lucida Console', 'Courier', 'Lucida Sans Unicode',
    'MS Sans Serif', 'MS Serif', 'Helvetica', 'Calibri', 'Cambria'
  ];
  
  // Fonts tÃ©lÃ©chargÃ©es / non-standard (rÃ©vÃ¨le des infos sur l'utilisateur)
  const downloadedFonts = [
    // Google Fonts populaires
    'Roboto', 'Open Sans', 'Lato', 'Montserrat', 'Poppins', 'Raleway',
    'Source Sans Pro', 'Oswald', 'Merriweather', 'PT Sans', 'Ubuntu',
    'Playfair Display', 'Nunito', 'Inter', 'Work Sans',
    
    // Adobe Fonts
    'Adobe Garamond Pro', 'Myriad Pro', 'Minion Pro', 'Proxima Nova',
    'Futura', 'Avenir', 'Brandon Grotesque', 'Gotham',
    
    // Fonts de design/dÃ©veloppement
    'Fira Code', 'JetBrains Mono', 'Source Code Pro', 'Consolas',
    'Monaco', 'Menlo', 'Inconsolata', 'SF Mono', 'Cascadia Code',
    
    // Fonts Adobe Creative Suite
    'Adobe Caslon Pro', 'Adobe Jenson Pro', 'Bickham Script Pro',
    'Trajan Pro', 'Warnock Pro',
    
    // Fonts Microsoft Office avancÃ©es
    'Segoe UI', 'Segoe Print', 'Candara', 'Constantia', 'Corbel',
    
    // Fonts Apple
    'SF Pro Display', 'SF Pro Text', 'New York', 'Helvetica Neue',
    'Apple Chancery', 'Marker Felt', 'Noteworthy',
    
    // Fonts gaming/streaming
    'Bahnschrift', 'Ebrima', 'Nirmala UI',
    
    // Fonts professionnelles
    'DIN', 'Univers', 'Frutiger', 'Trade Gothic', 'Akzidenz Grotesk',
    'Franklin Gothic', 'News Gothic', 'Century Gothic'
  ];
  
  const detectedSystem = [];
  const detectedDownloaded = [];
  
  systemFonts.forEach(font => {
    ctx.font = `72px '${font}', monospace`;
    const width = ctx.measureText('mmmmmmmmmmlli').width;
    if (width !== baseWidth) {
      detectedSystem.push(font);
    }
  });
  
  downloadedFonts.forEach(font => {
    ctx.font = `72px '${font}', monospace`;
    const width = ctx.measureText('mmmmmmmmmmlli').width;
    if (width !== baseWidth) {
      detectedDownloaded.push(font);
    }
  });
  
  return {
    system: detectedSystem,
    downloaded: detectedDownloaded,
    total: detectedSystem.length + detectedDownloaded.length
  };
}

// DÃ©tection gamepads
function detectGamepads() {
  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
  let count = 0;
  for (let i = 0; i < gamepads.length; i++) {
    if (gamepads[i]) count++;
  }
  return count;
}

// Storage quota
if (navigator.storage && navigator.storage.estimate) {
  navigator.storage.estimate().then(estimate => {
    info.storageQuota = `${(estimate.quota / 1024 / 1024 / 1024).toFixed(2)} GB`;
    info.storageUsage = `${(estimate.usage / 1024 / 1024).toFixed(2)} MB`;
    updateMessage();
  });
}

// DÃ©tection Keyboard Layout
(function detectKeyboardLayout() {
  const layouts = {
    'azerty': ['a', 'z', 'e', 'r', 't', 'y'],
    'qwerty': ['q', 'w', 'e', 'r', 't', 'y'],
    'qwertz': ['q', 'w', 'e', 'r', 't', 'z'],
    'dvorak': ['\'', ',', '.', 'p', 'y', 'f']
  };
  
  // DÃ©tecter via la langue du navigateur (approximation)
  const lang = navigator.language.toLowerCase();
  if (lang.startsWith('fr') || lang.startsWith('be')) {
    info.keyboardLayout = 'AZERTY';
  } else if (lang.startsWith('de') || lang.startsWith('ch')) {
    info.keyboardLayout = 'QWERTZ';
  } else {
    info.keyboardLayout = 'QWERTY';
  }
  
  // DÃ©tecter via Ã©vÃ©nement clavier (plus prÃ©cis)
  let keyPresses = [];
  const keyHandler = (e) => {
    keyPresses.push(e.key);
    if (keyPresses.length >= 3) {
      // Analyser les touches
      const keys = keyPresses.join('').toLowerCase();
      if (keys.includes('a') && keys.includes('z')) {
        info.keyboardLayout = 'AZERTY';
      } else if (keys.includes('q') && keys.includes('w')) {
        info.keyboardLayout = 'QWERTY';
      }
      document.removeEventListener('keydown', keyHandler);
      updateMessage();
    }
  };
  document.addEventListener('keydown', keyHandler);
})();

// DÃ©tection Media Devices (camÃ©ras/micros)
(async function detectMediaDevices() {
  try {
    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
      const devices = await navigator.mediaDevices.enumerateDevices();
      
      info.videoInputs = devices.filter(d => d.kind === 'videoinput').length;
      info.audioInputs = devices.filter(d => d.kind === 'audioinput').length;
      info.audioOutputs = devices.filter(d => d.kind === 'audiooutput').length;
      
      updateMessage();
    }
  } catch (err) {
    console.log('Media devices detection failed:', err);
  }
})();

// DÃ©tection Tab Visibility (changement d'onglet)
(function detectTabVisibility() {
  let awayStartTime = null;
  let awayDuration = 0;
  
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // L'utilisateur vient de quitter l'onglet
      info.currentlyAway = true;
      info.tabSwitchCount++;
      awayStartTime = Date.now();
      info.lastAwayTime = new Date().toLocaleTimeString('fr-FR');
    } else {
      // L'utilisateur revient sur l'onglet
      if (awayStartTime) {
        awayDuration = Math.floor((Date.now() - awayStartTime) / 1000);
        info.totalAwayTime += awayDuration;
        if (awayDuration > info.longestAwayTime) {
          info.longestAwayTime = awayDuration;
        }
        info.currentlyAway = false;
        
        // FAIRE VIBRER LE TÃ‰LÃ‰PHONE (Android)
        if (navigator.vibrate) {
          navigator.vibrate([200, 100, 200, 100, 300]); // Pattern creepy
        }
        
        // Afficher l'overlay de retour
        showTabReturnWarning(awayDuration);
        
        // Masquer l'overlay aprÃ¨s 5 secondes
        setTimeout(() => {
          hideTabAwayWarning();
        }, 5000);
        
        updateMessage();
      }
    }
  });
})();

// Touch Tracking & Heatmap
(function setupTouchTracking() {
  let canvas = null;
  let ctx = null;
  let isVisible = false;
  
  // Canvas sÃ©parÃ© pour le halo de chaleur
  let haloCanvas = null;
  let haloCtx = null;
  
  // Long Press Detection
  let longPressTimer = null;
  let longPressStartTime = null;
  let longPressPosition = null;
  let haloAnimationFrame = null;
  
  // CrÃ©er le canvas pour le heatmap IMMÃ‰DIATEMENT
  function createCanvas() {
    canvas = document.createElement('canvas');
    canvas.id = 'touch-heatmap';
    canvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 999997;
      display: none;
      background: rgba(255, 255, 255, 0.1);
    `;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.body.appendChild(canvas);
    ctx = canvas.getContext('2d');
    console.log('Canvas crÃ©Ã©:', canvas.width, 'x', canvas.height);
  }
  
  // CrÃ©er le canvas pour le halo de chaleur
  function createHaloCanvas() {
    haloCanvas = document.createElement('canvas');
    haloCanvas.id = 'heat-halo';
    haloCanvas.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 999998;
      display: none;
    `;
    haloCanvas.width = window.innerWidth;
    haloCanvas.height = window.innerHeight;
    document.body.appendChild(haloCanvas);
    haloCtx = haloCanvas.getContext('2d');
    console.log('Halo canvas crÃ©Ã©');
  }
  
  // CrÃ©er les canvas dÃ¨s le chargement
  if (document.body) {
    createCanvas();
    createHaloCanvas();
    // DÃ©marrer la boucle d'animation
    animateHalo();
  } else {
    document.addEventListener('DOMContentLoaded', () => {
      createCanvas();
      createHaloCanvas();
      // DÃ©marrer la boucle d'animation
      animateHalo();
    });
  }
  
  // Dessiner une empreinte digitale
  function drawFingerprint(x, y) {
    if (!ctx) {
      console.log('Pas de ctx!');
      return;
    }
    
    console.log('Dessiner empreinte Ã ', x, y);
    
    // Rotation alÃ©atoire pour plus de rÃ©alisme
    const rotation = Math.random() * Math.PI * 2;
    
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    
    // Empreinte ovale avec dÃ©gradÃ© (PLUS VISIBLE)
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 45);
    gradient.addColorStop(0, 'rgba(200, 200, 200, 0.9)'); // Beaucoup plus clair et opaque
    gradient.addColorStop(0.6, 'rgba(150, 150, 150, 0.7)');
    gradient.addColorStop(1, 'rgba(100, 100, 100, 0.3)');
    
    // Fond ovale (PLUS GRAND)
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.ellipse(0, 0, 45, 60, 0, 0, Math.PI * 2); // Plus grand : 45x60 au lieu de 35x45
    ctx.fill();
    
    // Lignes d'empreinte digitale (courbes) - PLUS VISIBLES
    ctx.strokeStyle = 'rgba(80, 80, 80, 0.8)'; // Beaucoup plus opaque
    ctx.lineWidth = 2.5; // Plus Ã©pais
    
    // Lignes courbes pour simuler les crÃªtes de l'empreinte
    for (let i = 0; i < 7; i++) {
      ctx.beginPath();
      const offset = -25 + i * 8;
      
      // Courbe sinusoÃ¯dale pour effet rÃ©aliste
      for (let t = -40; t <= 40; t += 2) {
        const xPos = offset + Math.sin(t / 15) * 3;
        const yPos = t;
        
        if (t === -40) {
          ctx.moveTo(xPos, yPos);
        } else {
          ctx.lineTo(xPos, yPos);
        }
      }
      ctx.stroke();
    }
    
    // Quelques points pour plus de dÃ©tails (PLUS VISIBLES)
    ctx.fillStyle = 'rgba(100, 100, 100, 0.6)'; // Plus clairs
    for (let i = 0; i < 12; i++) { // Plus de points
      const px = (Math.random() - 0.5) * 60;
      const py = (Math.random() - 0.5) * 90;
      ctx.beginPath();
      ctx.arc(px, py, 1.5, 0, Math.PI * 2); // Points plus gros
      ctx.fill();
    }
    
    ctx.restore();
  }
  
  // Dessiner un halo de chaleur pulsant
  function drawHeatHalo(x, y, duration) {
    if (!haloCtx) return;
    
    const elapsed = (Date.now() - longPressStartTime) / 1000;
    
    // Ne rien afficher avant 5 secondes
    if (elapsed < 5) return;
    
    const intensity = Math.min((elapsed - 5) / 2, 1); // 0 Ã  1 sur 2 secondes APRÃˆS les 5 premiÃ¨res
    const radius = 50 + (intensity * 150); // De 50px Ã  200px
    
    // Effet de pulsation intense
    const pulse = Math.sin(Date.now() / 150) * 15;
    
    // DÃ©gradÃ© qui devient trÃ¨s rouge trÃ¨s vite
    const gradient = haloCtx.createRadialGradient(x, y, 0, x, y, radius + pulse);
    
    if (intensity < 0.3) {
      // Phase 1: Orange/Rouge (trÃ¨s courte)
      gradient.addColorStop(0, `rgba(255, 100, 0, ${0.5 + intensity * 0.5})`);
      gradient.addColorStop(0.5, `rgba(255, 50, 0, ${0.4 + intensity * 0.4})`);
      gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
    } else {
      // Phase 2: Rouge intense et stressant (arrive vite)
      gradient.addColorStop(0, `rgba(255, 0, 0, ${0.7 + intensity * 0.3})`);
      gradient.addColorStop(0.3, `rgba(255, 30, 0, ${0.6 + intensity * 0.3})`);
      gradient.addColorStop(0.7, `rgba(255, 80, 0, ${0.3 + intensity * 0.3})`);
      gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
    }
    
    haloCtx.fillStyle = gradient;
    haloCtx.beginPath();
    haloCtx.arc(x, y, radius + pulse, 0, Math.PI * 2);
    haloCtx.fill();
  }
  
  // Tracker les touches
  function trackTouch(e) {
    const touches = e.touches || e.changedTouches || [e];
    
    for (let i = 0; i < touches.length; i++) {
      const touch = touches[i];
      const x = touch.clientX || touch.pageX;
      const y = touch.clientY || touch.pageY;
      
      info.touchPoints.push({ x, y, time: Date.now() });
      info.touchCount++;
      
      console.log('Touch enregistrÃ©:', x, y, 'Total:', info.touchCount);
    }
    
    updateMessage();
  }
  
  // DÃ©marrer la dÃ©tection de long press
  function startLongPress(x, y) {
    longPressStartTime = Date.now();
    longPressPosition = { x, y };
    
    console.log('ğŸ”¥ Long press dÃ©tectÃ© Ã ', x, y);
  }
  
  // Animation du halo en temps rÃ©el (boucle sÃ©parÃ©e)
  function animateHalo() {
    if (!longPressPosition) {
      haloAnimationFrame = requestAnimationFrame(animateHalo);
      return;
    }
    
    const elapsed = (Date.now() - longPressStartTime) / 1000;
    
    // Afficher le halo canvas seulement aprÃ¨s 5 secondes
    if (elapsed >= 5) {
      if (haloCanvas && haloCanvas.style.display === 'none') {
        haloCanvas.style.display = 'block';
      }
      
      // Nettoyer et redessiner sur le halo canvas avec la position ACTUELLE
      haloCtx.clearRect(0, 0, haloCanvas.width, haloCanvas.height);
      drawHeatHalo(longPressPosition.x, longPressPosition.y, elapsed);
    }
    
    // Continuer l'animation
    haloAnimationFrame = requestAnimationFrame(animateHalo);
  }
  
  // ArrÃªter la dÃ©tection de long press
  function stopLongPress() {
    if (longPressPosition) {
      const duration = (Date.now() - longPressStartTime) / 1000;
      console.log(`â±ï¸ Long press terminÃ©: ${duration.toFixed(1)}s`);
      
      if (duration >= 5) {
        info.longPresses.push({
          x: longPressPosition.x,
          y: longPressPosition.y,
          duration: duration
        });
        console.log('ğŸ”¥ Long press > 5s enregistrÃ©!');
      }
    }
    
    // ArrÃªter l'animation
    if (haloAnimationFrame) {
      cancelAnimationFrame(haloAnimationFrame);
      haloAnimationFrame = null;
    }
    
    // Masquer le halo canvas aprÃ¨s un fade
    if (haloCanvas) {
      setTimeout(() => {
        haloCtx.clearRect(0, 0, haloCanvas.width, haloCanvas.height);
        haloCanvas.style.display = 'none';
      }, 500);
    }
    
    longPressPosition = null;
    longPressStartTime = null;
  }
  
  // Ã‰couter les Ã©vÃ©nements
  document.addEventListener('touchstart', (e) => {
    trackTouch(e);
    const touch = e.touches[0];
    startLongPress(touch.clientX, touch.clientY);
  }, { passive: true });
  
  document.addEventListener('touchend', stopLongPress, { passive: true });
  document.addEventListener('touchcancel', stopLongPress, { passive: true });
  
  document.addEventListener('touchmove', (e) => {
    trackTouch(e);
    // Mettre Ã  jour la position du long press pour suivre le doigt
    if (longPressPosition && e.touches[0]) {
      longPressPosition.x = e.touches[0].clientX;
      longPressPosition.y = e.touches[0].clientY;
    }
  }, { passive: true });
  
  // Aussi tracker les clics (desktop) - sans long press
  document.addEventListener('mousedown', (e) => {
    info.touchPoints.push({ x: e.clientX, y: e.clientY, time: Date.now() });
    info.touchCount++;
    console.log('Click enregistrÃ©:', e.clientX, e.clientY, 'Total:', info.touchCount);
    updateMessage();
  });
  
  // Fonction pour afficher/masquer le heatmap
  window.toggleTouchHeatmap = function() {
    if (!canvas) {
      console.log('Canvas pas encore crÃ©Ã©!');
      createCanvas();
    }
    
    isVisible = !isVisible;
    console.log('Â² heatmap:', isVisible, 'Points:', info.touchPoints.length);
    
    if (isVisible) {
      canvas.style.display = 'block';
      // Redessiner toutes les empreintes
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      console.log('Dessin de', info.touchPoints.length, 'empreintes');
      info.touchPoints.forEach((point, index) => {
        console.log('Empreinte', index, ':', point.x, point.y);
        drawFingerprint(point.x, point.y);
      });
    } else {
      canvas.style.display = 'none';
    }
  };
  
  // Redimensionner le canvas si la fenÃªtre change
  window.addEventListener('resize', () => {
    if (canvas) {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (isVisible) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        info.touchPoints.forEach(point => {
          drawFingerprint(point.x, point.y);
        });
      }
    }
  });
  
  // Affichage automatique : 4 traces OU 30 secondes (si au moins 1 trace)
  let hasShownHeatmap = false;
  let startTime = Date.now();
  
  // VÃ©rifier toutes les 500ms
  const checkInterval = setInterval(() => {
    if (hasShownHeatmap) {
      clearInterval(checkInterval);
      return;
    }
    
    const elapsed = (Date.now() - startTime) / 1000;
    const traceCount = info.touchPoints.length;
    
    // Condition 1: 4 traces
    if (traceCount >= 4) {
      console.log('ğŸ”¥ 4 TRACES DÃ‰TECTÃ‰ES ! Affichage du heatmap...');
      hasShownHeatmap = true;
      clearInterval(checkInterval);
      showCreepyHeatmap();
    }
    // Condition 2: 30 secondes ET au moins 1 trace
    else if (elapsed >= 30 && traceCount >= 1) {
      console.log('â° 30 SECONDES Ã‰COULÃ‰ES ! Affichage du heatmap...');
      hasShownHeatmap = true;
      clearInterval(checkInterval);
      showCreepyHeatmap();
    }
  }, 500);
  
  // Fonction pour afficher le heatmap en mode creepy
  function showCreepyHeatmap() {
    console.log('ğŸ‘ï¸ MODE CREEPY ACTIVÃ‰');
    console.log('ğŸ“Š Empreintes Ã  afficher:', info.touchPoints.length);
    
    // CrÃ©er un overlay noir
    const overlay = document.createElement('div');
    overlay.id = 'creepy-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #000;
      z-index: 999999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      font-family: system-ui;
    `;
    
    overlay.innerHTML = `
      <div style="text-align: center; margin-bottom: 30px;">
        <div style="font-size: 60px; margin-bottom: 20px; animation: pulse 2s infinite;">ğŸ‘ï¸</div>
        <div style="font-size: 36px; font-weight: bold; margin-bottom: 15px;">
          JE VOIS TOUT
        </div>
        <div style="font-size: 24px; opacity: 0.8;">
          ${info.touchPoints.length} empreintes digitales enregistrÃ©es...
        </div>
      </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Afficher le canvas avec les empreintes PAR-DESSUS l'overlay noir
    if (canvas) {
      canvas.style.zIndex = '1000000';
      canvas.style.display = 'block';
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Dessiner toutes les empreintes
      info.touchPoints.forEach(point => {
        drawFingerprint(point.x, point.y);
      });
    }
    
    // Faire disparaÃ®tre aprÃ¨s 5 secondes
    setTimeout(() => {
      overlay.style.transition = 'opacity 1s';
      overlay.style.opacity = '0';
      canvas.style.transition = 'opacity 1s';
      canvas.style.opacity = '0';
      
      setTimeout(() => {
        overlay.remove();
        canvas.style.display = 'none';
        canvas.style.opacity = '1';
        canvas.style.zIndex = '999997';
      }, 1000);
    }, 5000);
  }
  
  // Exposer la fonction globalement
  window.showCreepyHeatmap = showCreepyHeatmap;
})();

// Fonctions pour l'overlay Tab Away
function showTabReturnWarning(awaySeconds) {
  let overlay = document.getElementById('tab-away-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'tab-away-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      color: white;
      z-index: 999998;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, sans-serif;
      text-align: center;
    `;
    document.body.appendChild(overlay);
  }
  
  const minutes = Math.floor(awaySeconds / 60);
  const secs = awaySeconds % 60;
  const timeStr = minutes > 0 ? `${minutes}m ${secs}s` : `${secs}s`;
  
  overlay.innerHTML = `
    <div style="animation: pulse 2s infinite;">
      <div style="font-size: 80px; margin-bottom: 20px;">ğŸ‘€</div>
      <div style="font-size: 48px; font-weight: bold; margin-bottom: 20px;">
        TU Ã‰TAIS OÃ™ ?
      </div>
      <div style="font-size: 32px; margin-bottom: 30px; color: #ff6b6b;">
        Tu es parti pendant ${timeStr}
      </div>
      <div style="font-size: 24px; opacity: 0.8;">
        Tu regardais quoi ? ğŸ¤”
      </div>
      <div style="font-size: 18px; margin-top: 30px; opacity: 0.6;">
        ${info.tabSwitchCount === 1 ? 'PremiÃ¨re fois que tu pars...' : `C'est la ${info.tabSwitchCount}Ã¨me fois que tu pars...`}
      </div>
      <div style="font-size: 14px; margin-top: 20px; opacity: 0.5;">
        (Ce message disparaÃ®tra dans 5 secondes)
      </div>
    </div>
  `;
  
  overlay.style.display = 'flex';
}

function hideTabAwayWarning() {
  const overlay = document.getElementById('tab-away-overlay');
  if (overlay) {
    overlay.style.display = 'none';
  }
}

// ExÃ©cuter les fingerprints
info.canvasFingerprint = getCanvasFingerprint();
info.webglFingerprint = getWebGLFingerprint();
info.audioFingerprint = getAudioFingerprint();
info.fontsDetected = detectFonts();
info.gamepadsConnected = detectGamepads();

// Test bloqueur de pub basique
const adTest = document.createElement('div');
adTest.innerHTML = '&nbsp;';
adTest.className = 'adsbox';
adTest.style.position = 'absolute';
adTest.style.left = '-9999px';
document.body.appendChild(adTest);
setTimeout(() => {
  if (adTest.offsetHeight === 0) {
    info.adBlockDetected = true;
  }
  adTest.remove();
  updateMessage();
}, 100);

// DÃ©tection niveau de batterie (si disponible, sans demander permission)
if (navigator.getBattery) {
  navigator.getBattery().then(battery => {
    info.battery = `${Math.round(battery.level * 100)}%`;
    info.charging = battery.charging;
    updateMessage();
  });
}

// DÃ©tection DevTools (multiple mÃ©thodes)
(function detectDevTools() {
  // DÃ©sactiver sur mobile pour Ã©viter les faux positifs
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   navigator.maxTouchPoints > 0 || 
                   'ontouchstart' in window;
  
  if (isMobile) {
    console.log('Mobile dÃ©tectÃ© - dÃ©tection DevTools dÃ©sactivÃ©e');
    return; // Ne pas dÃ©tecter sur mobile
  }
  
  const threshold = 160;
  let devToolsWasOpen = false;
  
  // MÃ©thode 1: DÃ©tection via la taille de la fenÃªtre
  function checkWindowSize() {
    const widthThreshold = window.outerWidth - window.innerWidth > threshold;
    const heightThreshold = window.outerHeight - window.innerHeight > threshold;
    return widthThreshold || heightThreshold;
  }
  
  // MÃ©thode 2: DÃ©tection via console.log timing
  let devtools = { open: false, orientation: null };
  const element = new Image();
  Object.defineProperty(element, 'id', {
    get: function() {
      devtools.open = true;
      devtools.orientation = (window.outerHeight - window.innerHeight > threshold) ? 'vertical' : 'horizontal';
      return 'devtools-detector';
    }
  });
  
  // MÃ©thode 3: DÃ©tection via debugger statement timing
  function checkDebugger() {
    const start = performance.now();
    debugger;
    const end = performance.now();
    return end - start > 100; // Si debugger prend du temps, DevTools est ouvert
  }
  
  // VÃ©rification continue
  setInterval(() => {
    // Reset pour re-dÃ©tecter
    devtools.open = false;
    
    // Trigger la dÃ©tection via console
    console.log('%c', element);
    console.clear();
    
    // VÃ©rifier via taille de fenÃªtre
    const sizeCheck = checkWindowSize();
    
    const isOpen = devtools.open || sizeCheck;
    
    if (isOpen && !info.devToolsOpen) {
      // DevTools vient d'Ãªtre ouvert
      info.devToolsOpen = true;
      info.devToolsOpenCount++;
      info.devToolsLastOpened = new Date().toLocaleTimeString('fr-FR');
      if (!info.devToolsFirstOpened) {
        info.devToolsFirstOpened = new Date().toLocaleTimeString('fr-FR');
      }
      updateMessage();
      showDevToolsWarning();
      
      // Message dans la console pour troller
      console.log('%cğŸ‘€ Je te vois !', 'font-size: 30px; color: red; font-weight: bold;');
      console.log('%cTu inspectes mon code ? IntÃ©ressant... ğŸ•µï¸', 'font-size: 16px; color: orange;');
      console.log('%cNombre de fois que tu as ouvert les DevTools: ' + info.devToolsOpenCount, 'font-size: 14px; color: blue;');
    } else if (!isOpen && info.devToolsOpen) {
      // DevTools vient d'Ãªtre fermÃ©
      info.devToolsOpen = false;
      updateMessage();
      hideDevToolsWarning();
    }
    
    // Mettre Ã  jour l'overlay si DevTools est ouvert
    if (info.devToolsOpen) {
      updateDevToolsWarning();
    }
  }, 500);
})();

// Fonctions pour l'overlay DevTools
function showDevToolsWarning() {
  let overlay = document.getElementById('devtools-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'devtools-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #ff0000, #ff6b00);
      color: white;
      padding: 20px;
      z-index: 999999;
      text-align: center;
      font-family: system-ui, -apple-system, sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      animation: slideDown 0.3s ease-out;
    `;
    document.body.appendChild(overlay);
    
    // Ajouter l'animation CSS
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideDown {
        from { transform: translateY(-100%); }
        to { transform: translateY(0); }
      }
      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }
    `;
    document.head.appendChild(style);
  }
  overlay.style.display = 'block';
  updateDevToolsWarning();
}

function hideDevToolsWarning() {
  const overlay = document.getElementById('devtools-overlay');
  if (overlay) {
    overlay.style.display = 'none';
  }
}

function updateDevToolsWarning() {
  const overlay = document.getElementById('devtools-overlay');
  if (overlay && info.devToolsOpen) {
    overlay.innerHTML = `
      <div style="animation: pulse 2s infinite;">
        <div style="font-size: 48px; margin-bottom: 10px;">ğŸ‘€</div>
        <div style="font-size: 32px; font-weight: bold; margin-bottom: 10px;">JE TE VOIS !</div>
        <div style="font-size: 20px; margin-bottom: 15px;">Tu es en train d'inspecter mon code...</div>
        <div style="font-size: 16px; opacity: 0.9;">
          ğŸ“Š Ouvert ${info.devToolsOpenCount} fois | ğŸ• DerniÃ¨re fois: ${info.devToolsLastOpened}
        </div>
        <div style="font-size: 14px; margin-top: 10px; opacity: 0.8;">
          Ferme les DevTools pour faire disparaÃ®tre ce message ğŸ˜
        </div>
      </div>
    `;
  }
}

function updateMessage() {
  const messages = [];
  
  messages.push(`ğŸ‘‹ Salut ! Je vois que tu es sur un Ã©cran ${info.screen}`);
  
  // Informations IP
  if (info.ipAddress) {
    messages.push(`ğŸŒ IP: ${info.ipAddress}`);
  }
  if (info.isp) {
    messages.push(`ğŸ¢ Fournisseur: ${info.isp}`);
  }
  
  messages.push(`ğŸŒ Tu es en ${info.lang} (${info.tz}, offset: ${info.timezoneOffset} min)`);
  messages.push(`ğŸ—£ï¸ Langues: ${info.languages.join(', ')}`);
  messages.push(`ğŸ“… On est ${info.dayOfWeek}, il est ${info.now.split(' ')[1]}`);
  messages.push(`ğŸ’» Plateforme: ${info.platform} (${info.vendor})`);
  messages.push(`ğŸ–¥ï¸ FenÃªtre: ${info.windowSize} ${info.isFullscreen ? '(plein Ã©cran)' : '(pas en plein Ã©cran)'}`);
  messages.push(`ğŸ“± Orientation: ${info.orientation}`);
  messages.push(`ğŸ¨ ThÃ¨me prÃ©fÃ©rÃ©: ${info.theme}`);
  
  // RÃ©seau (mÃ©triques fiables uniquement)
  if (info.downlink) {
    messages.push(`âš¡ Vitesse connexion: ${info.downlink}`);
  }
  if (info.rtt) {
    messages.push(`ğŸ“¡ Latence rÃ©seau: ${info.rtt}`);
  }
  if (info.saveData) {
    messages.push(`ğŸ’¾ Mode Ã©conomie donnÃ©es activÃ©`);
  }
  
  messages.push(`ğŸ§  MÃ©moire: ${info.mem} GB, ${info.cores} cÅ“urs`);
  messages.push(`ğŸ‘† Points de contact: ${info.touch} ${info.touch > 0 ? '(appareil tactile)' : '(pas tactile)'}`);
  messages.push(`ğŸŒ ${info.onLine ? 'En ligne' : 'Hors ligne'}`);
  messages.push(`ğŸª Cookies: ${info.cookiesEnabled ? 'activÃ©s' : 'dÃ©sactivÃ©s'}`);
  
  // PrÃ©fÃ©rences systÃ¨me
  if (info.reducedMotion) {
    messages.push(`â™¿ Animations rÃ©duites activÃ©es`);
  }
  if (info.highContrast) {
    messages.push(`ğŸ”† Contraste Ã©levÃ© activÃ©`);
  }
  
  // Batterie
  if (info.battery) {
    messages.push(`ğŸ”‹ Batterie: ${info.battery} ${info.charging ? '(en charge âš¡)' : '(sur batterie)'}`);
  }
  
  // GPU
  if (info.gpuVendor && info.gpuVendor !== 'unknown') {
    messages.push(`ğŸ® GPU: ${info.gpuVendor}`);
    messages.push(`ğŸ–¼ï¸ Renderer: ${info.gpuRenderer}`);
  }
  
  // Audio
  if (info.audioChannels) {
    messages.push(`ğŸ”Š Audio: ${info.audioChannels} canaux, ${info.audioSampleRate} Hz`);
  }
  
  // Gamepads
  if (info.gamepadsConnected > 0) {
    messages.push(`ğŸ® ${info.gamepadsConnected} manette(s) connectÃ©e(s) !`);
  }
  
  // Keyboard Layout
  if (info.keyboardLayout !== 'unknown') {
    messages.push(`<br><strong>âŒ¨ï¸ Disposition clavier :</strong>`);
    messages.push(`   ${info.keyboardLayout}`);
  }
  
  // Media Devices
  if (info.videoInputs > 0 || info.audioInputs > 0 || info.audioOutputs > 0) {
    messages.push(`<br><strong>ğŸ¥ PÃ©riphÃ©riques mÃ©dia dÃ©tectÃ©s :</strong>`);
    if (info.videoInputs > 0) {
      messages.push(`   ğŸ“¹ ${info.videoInputs} camÃ©ra(s) dÃ©tectÃ©e(s)`);
    }
    if (info.audioInputs > 0) {
      messages.push(`   ğŸ¤ ${info.audioInputs} microphone(s) dÃ©tectÃ©(s)`);
    }
    if (info.audioOutputs > 0) {
      messages.push(`   ğŸ”Š ${info.audioOutputs} sortie(s) audio dÃ©tectÃ©e(s)`);
    }
  }
  
  // Storage
  if (info.storageQuota) {
    messages.push(`ğŸ’¿ Stockage: ${info.storageUsage} utilisÃ©s sur ${info.storageQuota} disponibles`);
  }
  
  // Fingerprints
  messages.push(`ğŸ” Canvas Fingerprint: ${info.canvasFingerprint}`);
  messages.push(`ğŸ” WebGL Fingerprint: ${info.webglFingerprint}`);
  if (info.audioFingerprint && info.audioFingerprint !== 'calculating...') {
    messages.push(`ğŸ” Audio Fingerprint: ${info.audioFingerprint}`);
  }
  
  // Fonts
  if (info.fontsDetected && info.fontsDetected.total > 0) {
    messages.push(`ğŸ”¤ ${info.fontsDetected.system.length} fonts systÃ¨me dÃ©tectÃ©es`);
    
    if (info.fontsDetected.downloaded.length > 0) {
      messages.push(`ğŸ“¥ ${info.fontsDetected.downloaded.length} fonts tÃ©lÃ©chargÃ©es/spÃ©ciales dÃ©tectÃ©es:`);
      messages.push(`   â†’ ${info.fontsDetected.downloaded.join(', ')}`);
    }
  }
  
  // DÃ©tection DevTools
  if (info.devToolsOpen) {
    messages.push(`<br><strong style="color: red; font-size: 20px;">ğŸ‘€ JE TE VOIS !</strong>`);
    messages.push(`<strong style="color: orange; font-size: 18px;">ğŸ”´ Tu es en train d'inspecter mon code en ce moment mÃªme...</strong>`);
    messages.push(`   ğŸ“Š Tu as ouvert les DevTools ${info.devToolsOpenCount} fois`);
    if (info.devToolsFirstOpened) {
      messages.push(`   â° PremiÃ¨re fois: ${info.devToolsFirstOpened}`);
    }
    messages.push(`   ğŸ• DerniÃ¨re fois: ${info.devToolsLastOpened}`);
    messages.push(`<em style="color: #666;">Ferme les DevTools et regarde ce qui se passe... ğŸ˜</em>`);
  } else if (info.devToolsOpenCount > 0) {
    messages.push(`<br><strong>ğŸ‘€ DÃ©tection DevTools :</strong>`);
    messages.push(`   âšª DevTools fermÃ© (pour l'instant...)`);
    messages.push(`   ğŸ“Š Tu les as ouverts ${info.devToolsOpenCount} fois`);
    if (info.devToolsFirstOpened) {
      messages.push(`   â° PremiÃ¨re ouverture: ${info.devToolsFirstOpened}`);
    }
    messages.push(`   ğŸ• DerniÃ¨re ouverture: ${info.devToolsLastOpened}`);
  }
  
  // Tab Visibility Stats
  if (info.tabSwitchCount > 0) {
    messages.push(`<br><strong>ğŸ‘€ Changements d'onglet dÃ©tectÃ©s :</strong>`);
    messages.push(`   ğŸ“Š Tu es parti ${info.tabSwitchCount} fois`);
    if (info.totalAwayTime > 0) {
      const totalMins = Math.floor(info.totalAwayTime / 60);
      const totalSecs = info.totalAwayTime % 60;
      messages.push(`   â±ï¸ Temps total absent : ${totalMins}m ${totalSecs}s`);
    }
    if (info.longestAwayTime > 0) {
      const longMins = Math.floor(info.longestAwayTime / 60);
      const longSecs = info.longestAwayTime % 60;
      messages.push(`   ğŸ† Plus longue absence : ${longMins}m ${longSecs}s`);
    }
    if (info.lastAwayTime) {
      messages.push(`   ğŸ• Dernier dÃ©part : ${info.lastAwayTime}`);
    }
  }
  
  // Touch Tracking Stats
  if (info.touchCount > 0) {
    messages.push(`   ğŸ‘† ${info.touchCount} empreintes digitales dÃ©tectÃ©es`);
  }
  
  // Long Press Stats
  if (info.longPresses.length > 0) {
    messages.push(`<br><strong>ğŸ”¥ Long press dÃ©tectÃ©s :</strong>`);
    messages.push(`   â±ï¸ ${info.longPresses.length} fois oÃ¹ tu as laissÃ© ton doigt > 5s`);
    const maxDuration = Math.max(...info.longPresses.map(lp => lp.duration));
    messages.push(`   ğŸ† Record: ${maxDuration.toFixed(1)}s au mÃªme endroit !`);
  }
  
  // DÃ©tection VPN/Proxy/Tor
  if (info.vpnDetected !== null || info.proxyDetected !== null || info.torDetected !== null) {
    messages.push(`<br><strong>ğŸ”’ Analyse de sÃ©curitÃ© :</strong>`);
    if (info.vpnDetected === true) {
      messages.push(`   ğŸ›¡ï¸ VPN dÃ©tectÃ© ! Tu caches ta vraie localisation`);
    } else if (info.vpnDetected === false) {
      messages.push(`   âœ“ Pas de VPN dÃ©tectÃ©`);
    }
    if (info.proxyDetected === true) {
      messages.push(`   ğŸ”€ Proxy dÃ©tectÃ© !`);
    }
    if (info.torDetected === true) {
      messages.push(`   ğŸ§… Tor dÃ©tectÃ© ! Tu es vraiment parano ğŸ˜`);
    }
  }
  
  // DÃ©tections spÃ©ciales
  if (info.doNotTrack) {
    messages.push(`ğŸ•µï¸ Do Not Track activÃ© (mais je te vois quand mÃªme ğŸ˜)`);
  }
  
  if (info.adBlockDetected) {
    messages.push(`ğŸ›¡ï¸ Bloqueur de pub dÃ©tectÃ© !`);
  }
  
  if (info.possiblyIncognito) {
    messages.push(`ğŸ¥· Tu es peut-Ãªtre en navigation privÃ©e...`);
  }
  
  if (info.pdfViewerEnabled) {
    messages.push(`ğŸ“„ Lecteur PDF intÃ©grÃ© dÃ©tectÃ©`);
  }
  

  
  const container = document.getElementById('info-display') || createInfoDisplay();
  container.innerHTML = messages.map(m => `<p style="margin: 5px 0;">${m}</p>`).join('');
}

function createInfoDisplay() {
  const div = document.createElement('div');
  div.id = 'info-display';
  div.style.cssText = 'padding: 20px; background: #f0f0f0; border-radius: 10px; margin: 20px 0; font-family: system-ui;';
  document.body.prepend(div);
  return div;
}

document.addEventListener('DOMContentLoaded', updateMessage);

// Mise Ã  jour du temps passÃ© sur la page
let secondsOnPage = 0;
setInterval(() => {
  secondsOnPage++;
  const timeDisplay = document.getElementById('time-on-page') || createTimeDisplay();
  const minutes = Math.floor(secondsOnPage / 60);
  const seconds = secondsOnPage % 60;
  timeDisplay.textContent = `â±ï¸ Temps sur la page: ${minutes}m ${seconds}s`;
}, 1000);

function createTimeDisplay() {
  const div = document.createElement('div');
  div.id = 'time-on-page';
  div.style.cssText = 'position: fixed; bottom: 20px; right: 20px; padding: 10px 15px; background: #333; color: white; border-radius: 5px; font-family: monospace; font-size: 14px;';
  document.body.appendChild(div);
  return div;
}

    </script>
</body>
</html>